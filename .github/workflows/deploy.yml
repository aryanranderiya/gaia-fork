name: Deploy to GCP

# Deploys the production backend stack (core services + bots profile) on GCP VM.
on:
  # External dispatch from build workflow.
  repository_dispatch:
    types: [deploy]
  # Manual operator trigger.
  workflow_dispatch:
  # Reusable invocation from other workflows.
  workflow_call:

concurrency:
  # Prevent overlapping production deploys on the same ref.
  group: deploy-gcp-${{ github.ref }}
  cancel-in-progress: false

permissions:
  # Workflow reads repository metadata and updates status checks.
  contents: read
  statuses: write

jobs:
  deploy:
    runs-on: blacksmith-4vcpu-ubuntu-2404
    environment: production
    env:
      # Compose file and profile are centralized so deploy/verify use identical scope.
      COMPOSE_FILE: infra/docker/docker-compose.prod.yml
      COMPOSE_PROFILE: bots

    # Needed for OIDC -> Workload Identity Federation auth.
    permissions:
      contents: "read"
      id-token: "write"

    steps:
      # Authenticate keylessly (no long-lived JSON service account key).
      - name: Authenticate to Google Cloud via Workload Identity Federation
        uses: google-github-actions/auth@v2
        with:
          token_format: access_token
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      # Install gcloud CLI for SSH and registry auth commands.
      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v3
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      # Configure runner Docker client auth for gcr/gar use if needed.
      - name: Configure Docker to use gcloud as credential helper
        run: gcloud auth configure-docker

      # Authenticate runner to GHCR (used by any local image operations in workflow).
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # SSH into VM: sync repo, pull images, and recreate changed containers in-place.
      - name: Deploy application on GCP VM
        env:
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
        run: |
          gcloud compute ssh ubuntu@gaia-backend \
            --zone=$GCP_ZONE \
            --command="
              set -euo pipefail
              cd /home/aryan/gaia
              COMPOSE_FILE='${{ env.COMPOSE_FILE }}'
              COMPOSE_PROFILE='${{ env.COMPOSE_PROFILE }}'
              # compose_cmd includes the bots profile; core_cmd targets only core services.
              compose_cmd() { docker compose -f \"\$COMPOSE_FILE\" --profile \"\$COMPOSE_PROFILE\" \"\$@\"; }
              core_cmd()    { docker compose -f \"\$COMPOSE_FILE\" \"\$@\"; }

              git fetch origin master
              git checkout master
              git pull --ff-only origin master

              # Authenticate to GHCR on the VM before pulling images.
              echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin

              # Phase 1 â€” Pull core service images (must succeed).
              core_cmd pull

              # Phase 2 â€” Pull each bot image individually; failures are
              # non-fatal since images are only pushed when bot code changes.
              # Docker Compose v2 --ignore-pull-failures still exits non-zero
              # for missing registry refs, so we pull bots one-by-one instead.
              BOT_SERVICES='discord-bot slack-bot telegram-bot'
              for bot in \$BOT_SERVICES; do
                compose_cmd pull \"\$bot\" || echo \"âš ï¸  \$bot pull failed (see error above)\"
              done

              # Phase 3 â€” Start core services.
              # Do NOT use --remove-orphans here: core_cmd excludes the bots
              # profile, so compose would treat running bot containers as
              # orphans and remove them.
              core_cmd up -d

              # Phase 4 â€” Start bots whose images are available locally.
              # Failures are non-fatal so a broken bot cannot block API deploys.
              for bot in \$BOT_SERVICES; do
                img=\"ghcr.io/theexperiencecompany/gaia-bot-\${bot%-bot}:latest\"
                if docker image inspect \"\$img\" &>/dev/null; then
                  compose_cmd up -d \"\$bot\" || echo \"âš ï¸  \$bot failed to start (see error above)\"
                else
                  echo \"â„¹ï¸  \$bot skipped â€” no local image\"
                fi
              done

              # Best-effort orphan cleanup: uses full scope (with bots profile)
              # so profiled services are not mistakenly removed. --no-recreate
              # avoids touching already-running containers; errors are expected
              # if some bot images are missing.
              compose_cmd up -d --no-recreate --remove-orphans 2>/dev/null || true

              docker image prune -f
            "

      # Validate that every expected compose service is running and healthy.
      # Core services are mandatory; bot services are only checked when their
      # image exists locally (images are only pushed when bot code changes).
      - name: Verify deployment
        env:
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
        run: |
          output=$(gcloud compute ssh ubuntu@gaia-backend \
            --zone=$GCP_ZONE \
            --command="
              set -euo pipefail
              cd /home/aryan/gaia
              COMPOSE_FILE='${{ env.COMPOSE_FILE }}'
              COMPOSE_PROFILE='${{ env.COMPOSE_PROFILE }}'
              compose_cmd() { docker compose -f \"\$COMPOSE_FILE\" --profile \"\$COMPOSE_PROFILE\" \"\$@\"; }
              core_cmd()    { docker compose -f \"\$COMPOSE_FILE\" \"\$@\"; }

              running=\$(compose_cmd ps --status running --services)

              verify_svc() {
                local svc=\$1
                cid=\$(compose_cmd ps -q \"\$svc\")
                if [ -z \"\$cid\" ]; then
                  echo \"FAIL: missing container id for: \$svc\"
                  return 1
                fi
                status=\$(docker inspect -f '{{.State.Status}}' \"\$cid\")
                health=\$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' \"\$cid\")
                echo \"  \$svc => status=\$status health=\$health\"
                if [ \"\$status\" != \"running\" ]; then
                  echo \"FAIL: not running: \$svc\"
                  return 1
                fi
                if [ \"\$health\" != \"none\" ] && [ \"\$health\" != \"healthy\" ]; then
                  echo \"FAIL: unhealthy: \$svc (\$health)\"
                  return 1
                fi
              }

              # --- Core services (mandatory) ---
              echo 'Core services:'
              core_expected=\$(core_cmd config --services)
              for svc in \$core_expected; do
                if ! echo \"\$running\" | grep -qx \"\$svc\"; then
                  echo \"FAIL: core service not running: \$svc\"
                  exit 1
                fi
                verify_svc \"\$svc\" || exit 1
              done

              # --- Bot services (advisory â€” never fail the deploy) ---
              echo ''
              echo 'Bot services:'
              BOT_SERVICES='discord-bot slack-bot telegram-bot'
              for bot in \$BOT_SERVICES; do
                img=\"ghcr.io/theexperiencecompany/gaia-bot-\${bot%-bot}:latest\"
                if ! docker image inspect \"\$img\" &>/dev/null; then
                  echo \"  \$bot => skipped (no local image)\"
                  continue
                fi
                if ! echo \"\$running\" | grep -qx \"\$bot\"; then
                  echo \"  âš ï¸  \$bot => not running (image exists locally)\"
                  continue
                fi
                verify_svc \"\$bot\" || echo \"  âš ï¸  \$bot => unhealthy\"
              done
            ")

          echo "$output"

          echo "âœ… All expected services are running and healthy"

      # Reclaim disk space from dangling artifacts on the VM.
      - name: Docker Cleanup
        env:
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
        run: |
          gcloud compute ssh ubuntu@gaia-backend \
            --zone=$GCP_ZONE \
            --command="
              echo 'Starting Docker cleanup...'

              # Remove dangling images
              docker image prune -f

              # Remove stopped containers
              docker container prune -f

              # Remove unused networks
              docker network prune -f

              echo 'âœ… Docker cleanup completed.'
            "

      # Always emit deploy status to Discord for ops visibility.
      - name: Notify to Discord
        if: always()
        uses: appleboy/discord-action@v1.2.0
        with:
          webhook_url: ${{ secrets.DISCORD_WEBHOOK }}
          username: "Gaia Deploy Bot"
          color: ${{ job.status == 'success' && '#48f442' || '#ff6b6b' }}
          message: |
            ðŸš€ **Deployment to GCP**

            **Repository:** ${{ github.repository }}
            **Branch:** ${{ github.ref_name }}
            **Commit:** ${{ github.sha }}
            **Status:** ${{ job.status }}
            **Deploy Scope:** api-and-bots
            **Deployed by:** ${{ github.actor }}
            **Timestamp:** ${{ github.run_id }}
