name: Deploy to GCP

# Deploys the production backend stack (core services + bots profile) on GCP VM.
on:
  # External dispatch from build workflow.
  repository_dispatch:
    types: [deploy]
  # Manual operator trigger.
  workflow_dispatch:
  # Reusable invocation from other workflows.
  workflow_call:

concurrency:
  # Prevent overlapping production deploys on the same ref.
  group: deploy-gcp-${{ github.ref }}
  cancel-in-progress: false

permissions:
  # Workflow reads repository metadata and updates status checks.
  contents: read
  statuses: write

jobs:
  deploy:
    runs-on: blacksmith-4vcpu-ubuntu-2404
    environment: production
    env:
      # Compose file and profile are centralized so deploy/verify use identical scope.
      COMPOSE_FILE: infra/docker/docker-compose.prod.yml
      COMPOSE_PROFILE: bots

    # Needed for OIDC -> Workload Identity Federation auth.
    permissions:
      contents: "read"
      id-token: "write"

    steps:
      # Authenticate keylessly (no long-lived JSON service account key).
      - name: Authenticate to Google Cloud via Workload Identity Federation
        uses: google-github-actions/auth@v2
        with:
          token_format: access_token
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      # Install gcloud CLI for SSH and registry auth commands.
      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v3
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      # Configure runner Docker client auth for gcr/gar use if needed.
      - name: Configure Docker to use gcloud as credential helper
        run: gcloud auth configure-docker

      # Authenticate runner to GHCR (used by any local image operations in workflow).
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # SSH into VM: sync repo, pull images, and recreate changed containers in-place.
      - name: Deploy application on GCP VM
        env:
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
        run: |
          gcloud compute ssh ubuntu@gaia-backend \
            --zone=$GCP_ZONE \
            --command="
              set -euo pipefail
              cd /home/aryan/gaia
              COMPOSE_FILE='${{ env.COMPOSE_FILE }}'
              COMPOSE_PROFILE='${{ env.COMPOSE_PROFILE }}'
              # Intentionally deploy full production stack: core services (always
              # active) + bots profile.
              compose_cmd() { docker compose -f \"\$COMPOSE_FILE\" --profile \"\$COMPOSE_PROFILE\" \"\$@\"; }

              git fetch origin master
              git checkout master
              git pull --ff-only origin master

              # Authenticate to GHCR on the VM before pulling images.
              echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin

              # Pull updated images; ignore failures for bot images not yet pushed to GHCR.
              compose_cmd pull --ignore-pull-failures

              # Recreate only what changed while keeping the stack online.
              compose_cmd up -d --remove-orphans
              docker image prune -f
            "

      # Validate that every expected compose service is running and healthy.
      - name: Verify deployment
        env:
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
        run: |
          output=$(gcloud compute ssh ubuntu@gaia-backend \
            --zone=$GCP_ZONE \
            --command="
              set -euo pipefail
              cd /home/aryan/gaia
              COMPOSE_FILE='${{ env.COMPOSE_FILE }}'
              COMPOSE_PROFILE='${{ env.COMPOSE_PROFILE }}'
              compose_cmd() { docker compose -f \"\$COMPOSE_FILE\" --profile \"\$COMPOSE_PROFILE\" \"\$@\"; }

              expected_services=\$(compose_cmd config --services)
              running_services=\$(compose_cmd ps --status running --services)

              echo 'Expected services:'
              echo \"\$expected_services\"
              echo
              echo 'Running services:'
              echo \"\$running_services\"
              echo

              for svc in \$expected_services; do
                if ! echo \"\$running_services\" | grep -qx \"\$svc\"; then
                  echo \"Service not running: \$svc\"
                  exit 1
                fi

                cid=\$(compose_cmd ps -q \"\$svc\")
                if [ -z \"\$cid\" ]; then
                  echo \"Missing container id for service: \$svc\"
                  exit 1
                fi

                status=\$(docker inspect -f '{{.State.Status}}' \"\$cid\")
                health=\$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' \"\$cid\")
                echo \"\$svc => status=\$status health=\$health\"

                if [ \"\$status\" != \"running\" ]; then
                  echo \"Service not in running state: \$svc\"
                  exit 1
                fi

                if [ \"\$health\" != \"none\" ] && [ \"\$health\" != \"healthy\" ]; then
                  echo \"Service health check failed: \$svc (\$health)\"
                  exit 1
                fi
              done
            ")

          echo "$output"

          echo "âœ… All expected services are running and healthy"

      # Reclaim disk space from dangling artifacts on the VM.
      - name: Docker Cleanup
        env:
          GCP_ZONE: ${{ secrets.GCP_ZONE }}
        run: |
          gcloud compute ssh ubuntu@gaia-backend \
            --zone=$GCP_ZONE \
            --command="
              echo 'Starting Docker cleanup...'

              # Remove dangling images
              docker image prune -f

              # Remove stopped containers
              docker container prune -f

              # Remove unused networks
              docker network prune -f

              echo 'âœ… Docker cleanup completed.'
            "

      # Always emit deploy status to Discord for ops visibility.
      - name: Notify to Discord
        if: always()
        uses: appleboy/discord-action@v1.2.0
        with:
          webhook_url: ${{ secrets.DISCORD_WEBHOOK }}
          username: "Gaia Deploy Bot"
          color: ${{ job.status == 'success' && '#48f442' || '#ff6b6b' }}
          message: |
            ðŸš€ **Deployment to GCP**

            **Repository:** ${{ github.repository }}
            **Branch:** ${{ github.ref_name }}
            **Commit:** ${{ github.sha }}
            **Status:** ${{ job.status }}
            **Deploy Scope:** api-and-bots
            **Deployed by:** ${{ github.actor }}
            **Timestamp:** ${{ github.run_id }}
