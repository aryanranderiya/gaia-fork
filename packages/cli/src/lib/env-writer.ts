import * as fs from "fs";
import * as path from "path";
import {
  getWebInfrastructureDefaults,
  parseWebEnv,
  type SetupMode,
} from "./env-parser.js";

export interface EnvValues {
  [key: string]: string;
}

/**
 * Returns the canonical path to the API .env file.
 * Note: writeEnvFile() expects path.join(repoRoot, "apps", "api") as its repoPath
 * argument, so it writes to apps/api/.env correctly. These helpers exist so that
 * envFileExists() and readEnvFile() — which take the monorepo root — resolve
 * the same location.
 */
export function getApiEnvPath(repoRoot: string): string {
  return path.join(repoRoot, "apps", "api", ".env");
}

export function getWebEnvPath(repoRoot: string): string {
  return path.join(repoRoot, "apps", "web", ".env.local");
}

function backupIfExists(filePath: string): void {
  if (fs.existsSync(filePath)) {
    fs.copyFileSync(filePath, `${filePath}.bak`);
  }
}

export function writeEnvFile(repoPath: string, values: EnvValues): void {
  const envPath = path.join(repoPath, ".env");
  backupIfExists(envPath);

  const lines: string[] = [
    "# GAIA Environment Configuration",
    "# Generated by GAIA CLI",
    `# Created: ${new Date().toISOString()}`,
    "",
  ];

  const KNOWN_PREFIXES = [
    "MONGO",
    "REDIS",
    "POSTGRES",
    "CHROMADB",
    "RABBITMQ",
    "WORKOS",
    "GOOGLE",
    "OPENAI",
    "INFISICAL",
    "LANGSMITH",
    "DISCORD",
    "SLACK",
    "TELEGRAM",
    "CLOUDINARY",
    "COMPOSIO",
    "FIRECRAWL",
    "LIVEKIT",
    "DEEPGRAM",
    "ELEVENLABS",
    "RESEND",
    "SENTRY",
    "POSTHOG",
    "MEM0",
    "E2B",
    "DODO",
    "NEXT_PUBLIC",
    "GAIA",
  ];

  function getGroupKey(key: string): string {
    // Check known prefixes (longest match first for multi-word prefixes like NEXT_PUBLIC)
    for (const prefix of KNOWN_PREFIXES) {
      if (key === prefix || key.startsWith(`${prefix}_`)) {
        return prefix;
      }
    }
    // Single-word vars (no underscore) go into "Core"
    const parts = key.split("_");
    if (parts.length === 1) {
      return "Core";
    }
    // Unknown vars: group by first underscore segment
    return parts[0] || "Core";
  }

  const grouped: Map<string, string[]> = new Map();

  for (const [key, value] of Object.entries(values)) {
    const group = getGroupKey(key);
    if (!grouped.has(group)) {
      grouped.set(group, []);
    }
    // Quote value if it contains spaces, #, or other special chars
    const needsQuoting = /[\s#"'\\]/.test(value) || value === "";
    const quotedValue = needsQuoting
      ? `"${value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`
      : value;
    grouped.get(group)!.push(`${key}=${quotedValue}`);
  }

  for (const [prefix, vars] of grouped.entries()) {
    lines.push(`# ${prefix} Configuration`);
    lines.push(...vars);
    lines.push("");
  }

  fs.writeFileSync(envPath, lines.join("\n"), "utf-8");
}

export function writeWebEnvFile(
  repoPath: string,
  mode: SetupMode,
  portOverrides?: Record<number, number>,
): void {
  const webEnvPath = path.join(repoPath, "apps", "web", ".env.local");
  backupIfExists(webEnvPath);

  // Parse existing .env to discover all vars
  const discoveredVars = parseWebEnv(repoPath);
  const infraDefaults = getWebInfrastructureDefaults(mode, portOverrides);

  const lines: string[] = [
    "# GAIA Web App Environment Configuration",
    "# Generated by GAIA CLI",
    `# Created: ${new Date().toISOString()}`,
    "",
  ];

  // Group vars by category
  const categories = new Map<string, { name: string; value: string }[]>();

  for (const v of discoveredVars) {
    if (!categories.has(v.category)) {
      categories.set(v.category, []);
    }
    // Use infrastructure default if available, otherwise use discovered value
    const value = infraDefaults[v.name] ?? v.value;
    categories.get(v.category)!.push({ name: v.name, value });
  }

  // If no vars discovered, write infrastructure defaults
  if (discoveredVars.length === 0) {
    lines.push("# Core URLs");
    for (const [key, value] of Object.entries(infraDefaults)) {
      lines.push(`${key}=${value}`);
    }
    lines.push("");
  } else {
    for (const [category, vars] of categories.entries()) {
      lines.push(`# ${category}`);
      for (const { name, value } of vars) {
        lines.push(`${name}=${value}`);
      }
      lines.push("");
    }
  }

  fs.writeFileSync(webEnvPath, lines.join("\n"), "utf-8");
}

export const DOCKER_PORT_VAR_MAP: Record<number, string> = {
  8000: "API_HOST_PORT",
  5432: "POSTGRES_HOST_PORT",
  6379: "REDIS_HOST_PORT",
  27017: "MONGO_HOST_PORT",
  5672: "RABBITMQ_HOST_PORT",
  8080: "CHROMADB_HOST_PORT",
  8083: "MONGO_EXPRESS_HOST_PORT",
  3000: "WEB_HOST_PORT",
};

export function writeDockerComposeEnv(
  repoRoot: string,
  portOverrides: Record<number, number>,
  mode?: SetupMode,
): void {
  const envPath = path.join(repoRoot, "infra", "docker", ".env");
  backupIfExists(envPath);

  const lines: string[] = [
    "# Docker Compose environment overrides",
    "# Generated by GAIA CLI",
    `# Created: ${new Date().toISOString()}`,
    "",
  ];

  for (const [original, replacement] of Object.entries(portOverrides)) {
    const origPort = Number(original);
    const varName = DOCKER_PORT_VAR_MAP[origPort];
    if (varName) {
      lines.push(`${varName}=${replacement}`);
    }
  }

  // In selfhost mode, write the web build arg so docker-compose.selfhost.yml
  // can substitute it with the correct (possibly overridden) API port.
  if (mode === "selfhost") {
    const apiPort = portOverrides[8000] ?? 8000;
    lines.push("");
    lines.push("# Web build args");
    lines.push(`NEXT_PUBLIC_API_BASE_URL=http://localhost:${apiPort}/api/v1/`);
  }

  lines.push("");
  fs.writeFileSync(envPath, lines.join("\n"), "utf-8");
}

/**
 * Convert port overrides (e.g. {5432: 5433, 8080: 8081}) to Docker Compose
 * environment variable names (e.g. {POSTGRES_HOST_PORT: "5433", CHROMADB_HOST_PORT: "8081"}).
 * These can be passed as shell env vars to `docker compose`, where they take
 * highest priority over .env files and defaults in docker-compose.yml.
 */
export function portOverridesToDockerEnv(
  portOverrides: Record<number, number>,
): Record<string, string> {
  const env: Record<string, string> = {};
  for (const [original, replacement] of Object.entries(portOverrides)) {
    const origPort = Number(original);
    const varName = DOCKER_PORT_VAR_MAP[origPort];
    if (varName) {
      env[varName] = String(replacement);
    }
  }
  return env;
}

/**
 * Patch docker-compose.yml to use variable substitution for port mappings.
 * Converts hardcoded ports like `"5432:5432"` into `"${POSTGRES_HOST_PORT:-5432}:5432"`.
 * This is needed because older versions of the compose file have hardcoded ports,
 * and the .env override mechanism only works with variable substitution syntax.
 */
export function patchDockerComposePorts(repoRoot: string): void {
  const composePath = path.join(
    repoRoot,
    "infra",
    "docker",
    "docker-compose.yml",
  );
  if (!fs.existsSync(composePath)) return;

  let content = fs.readFileSync(composePath, "utf-8");

  const PORT_PATTERNS: Array<{
    varName: string;
    hostPort: number;
    containerPort: number;
  }> = [
    { varName: "API_HOST_PORT", hostPort: 8000, containerPort: 80 },
    { varName: "CHROMADB_HOST_PORT", hostPort: 8080, containerPort: 8000 },
    { varName: "POSTGRES_HOST_PORT", hostPort: 5432, containerPort: 5432 },
    { varName: "REDIS_HOST_PORT", hostPort: 6379, containerPort: 6379 },
    { varName: "MONGO_HOST_PORT", hostPort: 27017, containerPort: 27017 },
    { varName: "RABBITMQ_HOST_PORT", hostPort: 5672, containerPort: 5672 },
    {
      varName: "MONGO_EXPRESS_HOST_PORT",
      hostPort: 8083,
      containerPort: 8081,
    },
    { varName: "WEB_HOST_PORT", hostPort: 3000, containerPort: 3000 },
  ];

  let changed = false;
  for (const { varName, hostPort, containerPort } of PORT_PATTERNS) {
    const hardcoded = `"${hostPort}:${containerPort}"`;
    const variable = `"\${${varName}:-${hostPort}}:${containerPort}"`;
    if (content.includes(hardcoded)) {
      content = content.replaceAll(hardcoded, variable);
      changed = true;
    }
  }

  if (changed) {
    fs.writeFileSync(composePath, content, "utf-8");
  }
}

const DOCKER_PORT_VAR_TO_PORT: Record<string, number> = {
  API_HOST_PORT: 8000,
  POSTGRES_HOST_PORT: 5432,
  REDIS_HOST_PORT: 6379,
  MONGO_HOST_PORT: 27017,
  RABBITMQ_HOST_PORT: 5672,
  CHROMADB_HOST_PORT: 8080,
  MONGO_EXPRESS_HOST_PORT: 8083,
  WEB_HOST_PORT: 3000,
};

export function readDockerComposePortOverrides(
  repoRoot: string,
): Record<number, number> {
  const envPath = path.join(repoRoot, "infra", "docker", ".env");
  const overrides: Record<number, number> = {};

  if (!fs.existsSync(envPath)) {
    return overrides;
  }

  const content = fs.readFileSync(envPath, "utf-8");
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const [key, ...valueParts] = trimmed.split("=");
      if (key && DOCKER_PORT_VAR_TO_PORT[key]) {
        const cleaned = valueParts
          .join("=")
          .trim()
          .replace(/^["']|["']$/g, "");
        const port = Number(cleaned);
        if (!Number.isNaN(port) && port > 0 && port <= 65535) {
          overrides[DOCKER_PORT_VAR_TO_PORT[key]] = port;
        }
      }
    }
  }

  return overrides;
}

/**
 * Check if the API .env file exists. Pass the monorepo root as repoRoot.
 */
export function envFileExists(repoRoot: string): boolean {
  return fs.existsSync(getApiEnvPath(repoRoot));
}

/**
 * Read and parse the API .env file. Pass the monorepo root as repoRoot.
 */
export function readEnvFile(repoRoot: string): EnvValues {
  const envPath = getApiEnvPath(repoRoot);

  if (!fs.existsSync(envPath)) {
    return {};
  }

  const content = fs.readFileSync(envPath, "utf-8");
  const values: EnvValues = {};

  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const [key, ...valueParts] = trimmed.split("=");
      if (key) {
        let value = valueParts.join("=").trim();
        // Check if value is quoted
        const isQuoted =
          (value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"));
        if (isQuoted) {
          // Strip matching quotes, don't touch content
          value = value.slice(1, -1);
        } else {
          // Remove inline comments only for unquoted values
          const commentIdx = value.indexOf(" #");
          if (commentIdx !== -1) {
            value = value.substring(0, commentIdx).trim();
          }
        }
        values[key.trim()] = value;
      }
    }
  }

  return values;
}
