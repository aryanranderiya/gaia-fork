import * as fs from "fs";
import * as path from "path";
import {
  getWebInfrastructureDefaults,
  parseWebEnv,
  type SetupMode,
} from "./env-parser.js";

export interface EnvValues {
  [key: string]: string;
}

/**
 * Returns the canonical path to the API .env file.
 * Note: writeEnvFile() expects path.join(repoRoot, "apps", "api") as its repoPath
 * argument, so it writes to apps/api/.env correctly. These helpers exist so that
 * envFileExists() and readEnvFile() — which take the monorepo root — resolve
 * the same location.
 */
export function getApiEnvPath(repoRoot: string): string {
  return path.join(repoRoot, "apps", "api", ".env");
}

export function getWebEnvPath(repoRoot: string): string {
  return path.join(repoRoot, "apps", "web", ".env");
}

function backupIfExists(filePath: string): void {
  if (fs.existsSync(filePath)) {
    fs.copyFileSync(filePath, `${filePath}.bak`);
  }
}

export function writeEnvFile(repoPath: string, values: EnvValues): void {
  const envPath = path.join(repoPath, ".env");
  backupIfExists(envPath);

  const lines: string[] = [
    "# GAIA Environment Configuration",
    "# Generated by GAIA CLI",
    `# Created: ${new Date().toISOString()}`,
    "",
  ];

  const grouped: Map<string, string[]> = new Map();

  for (const [key, value] of Object.entries(values)) {
    const prefix = key.split("_")[0] || key;
    if (!grouped.has(prefix)) {
      grouped.set(prefix, []);
    }
    grouped.get(prefix)!.push(`${key}=${value}`);
  }

  for (const [prefix, vars] of grouped.entries()) {
    lines.push(`# ${prefix} Configuration`);
    lines.push(...vars);
    lines.push("");
  }

  fs.writeFileSync(envPath, lines.join("\n"), "utf-8");
}

export function writeWebEnvFile(
  repoPath: string,
  mode: SetupMode,
  portOverrides?: Record<number, number>,
): void {
  const webEnvPath = path.join(repoPath, "apps", "web", ".env");
  backupIfExists(webEnvPath);

  // Parse existing .env to discover all vars
  const discoveredVars = parseWebEnv(repoPath);
  const infraDefaults = getWebInfrastructureDefaults(mode, portOverrides);

  const lines: string[] = [
    "# GAIA Web App Environment Configuration",
    "# Generated by GAIA CLI",
    `# Created: ${new Date().toISOString()}`,
    "",
  ];

  // Group vars by category
  const categories = new Map<string, { name: string; value: string }[]>();

  for (const v of discoveredVars) {
    if (!categories.has(v.category)) {
      categories.set(v.category, []);
    }
    // Use infrastructure default if available, otherwise use discovered value
    const value = infraDefaults[v.name] ?? v.value;
    categories.get(v.category)!.push({ name: v.name, value });
  }

  // If no vars discovered, write infrastructure defaults
  if (discoveredVars.length === 0) {
    lines.push("# Core URLs");
    for (const [key, value] of Object.entries(infraDefaults)) {
      lines.push(`${key}=${value}`);
    }
    lines.push("");
  } else {
    for (const [category, vars] of categories.entries()) {
      lines.push(`# ${category}`);
      for (const { name, value } of vars) {
        lines.push(`${name}=${value}`);
      }
      lines.push("");
    }
  }

  fs.writeFileSync(webEnvPath, lines.join("\n"), "utf-8");
}

/**
 * Check if the API .env file exists. Pass the monorepo root as repoRoot.
 */
export function envFileExists(repoRoot: string): boolean {
  return fs.existsSync(getApiEnvPath(repoRoot));
}

/**
 * Read and parse the API .env file. Pass the monorepo root as repoRoot.
 */
export function readEnvFile(repoRoot: string): EnvValues {
  const envPath = getApiEnvPath(repoRoot);

  if (!fs.existsSync(envPath)) {
    return {};
  }

  const content = fs.readFileSync(envPath, "utf-8");
  const values: EnvValues = {};

  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const [key, ...valueParts] = trimmed.split("=");
      if (key) {
        values[key.trim()] = valueParts.join("=").trim();
      }
    }
  }

  return values;
}
