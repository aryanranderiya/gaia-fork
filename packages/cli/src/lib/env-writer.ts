import * as fs from "fs";
import * as path from "path";
import {
  getWebInfrastructureDefaults,
  parseWebEnv,
  type SetupMode,
} from "./env-parser.js";

export interface EnvValues {
  [key: string]: string;
}

/**
 * Returns the canonical path to the API .env file.
 * Note: writeEnvFile() expects path.join(repoRoot, "apps", "api") as its repoPath
 * argument, so it writes to apps/api/.env correctly. These helpers exist so that
 * envFileExists() and readEnvFile() — which take the monorepo root — resolve
 * the same location.
 */
export function getApiEnvPath(repoRoot: string): string {
  return path.join(repoRoot, "apps", "api", ".env");
}

export function getWebEnvPath(repoRoot: string): string {
  return path.join(repoRoot, "apps", "web", ".env.local");
}

function backupIfExists(filePath: string): void {
  if (fs.existsSync(filePath)) {
    fs.copyFileSync(filePath, `${filePath}.bak`);
  }
}

export function writeEnvFile(repoPath: string, values: EnvValues): void {
  const envPath = path.join(repoPath, ".env");
  backupIfExists(envPath);

  const lines: string[] = [
    "# GAIA Environment Configuration",
    "# Generated by GAIA CLI",
    `# Created: ${new Date().toISOString()}`,
    "",
  ];

  const KNOWN_PREFIXES = [
    "MONGO",
    "REDIS",
    "POSTGRES",
    "CHROMADB",
    "RABBITMQ",
    "WORKOS",
    "GOOGLE",
    "OPENAI",
    "INFISICAL",
    "LANGSMITH",
    "DISCORD",
    "SLACK",
    "TELEGRAM",
    "CLOUDINARY",
    "COMPOSIO",
    "FIRECRAWL",
    "LIVEKIT",
    "DEEPGRAM",
    "ELEVENLABS",
    "RESEND",
    "SENTRY",
    "POSTHOG",
    "MEM0",
    "E2B",
    "DODO",
    "NEXT_PUBLIC",
    "GAIA",
  ];

  function getGroupKey(key: string): string {
    // Check known prefixes (longest match first for multi-word prefixes like NEXT_PUBLIC)
    for (const prefix of KNOWN_PREFIXES) {
      if (key === prefix || key.startsWith(`${prefix}_`)) {
        return prefix;
      }
    }
    // Single-word vars (no underscore) go into "Core"
    const parts = key.split("_");
    if (parts.length === 1) {
      return "Core";
    }
    // Unknown vars: group by first underscore segment
    return parts[0] || "Core";
  }

  const grouped: Map<string, string[]> = new Map();

  for (const [key, value] of Object.entries(values)) {
    const group = getGroupKey(key);
    if (!grouped.has(group)) {
      grouped.set(group, []);
    }
    // Quote value if it contains spaces, #, or other special chars
    const needsQuoting = /[\s#"'\\]/.test(value) || value === "";
    const quotedValue = needsQuoting
      ? `"${value.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`
      : value;
    grouped.get(group)!.push(`${key}=${quotedValue}`);
  }

  for (const [prefix, vars] of grouped.entries()) {
    lines.push(`# ${prefix} Configuration`);
    lines.push(...vars);
    lines.push("");
  }

  fs.writeFileSync(envPath, lines.join("\n"), "utf-8");
}

export function writeWebEnvFile(
  repoPath: string,
  mode: SetupMode,
  portOverrides?: Record<number, number>,
): void {
  const webEnvPath = path.join(repoPath, "apps", "web", ".env.local");
  backupIfExists(webEnvPath);

  // Parse existing .env to discover all vars
  const discoveredVars = parseWebEnv(repoPath);
  const infraDefaults = getWebInfrastructureDefaults(mode, portOverrides);

  const lines: string[] = [
    "# GAIA Web App Environment Configuration",
    "# Generated by GAIA CLI",
    `# Created: ${new Date().toISOString()}`,
    "",
  ];

  // Group vars by category
  const categories = new Map<string, { name: string; value: string }[]>();

  for (const v of discoveredVars) {
    if (!categories.has(v.category)) {
      categories.set(v.category, []);
    }
    // Use infrastructure default if available, otherwise use discovered value
    const value = infraDefaults[v.name] ?? v.value;
    categories.get(v.category)!.push({ name: v.name, value });
  }

  // If no vars discovered, write infrastructure defaults
  if (discoveredVars.length === 0) {
    lines.push("# Core URLs");
    for (const [key, value] of Object.entries(infraDefaults)) {
      lines.push(`${key}=${value}`);
    }
    lines.push("");
  } else {
    for (const [category, vars] of categories.entries()) {
      lines.push(`# ${category}`);
      for (const { name, value } of vars) {
        lines.push(`${name}=${value}`);
      }
      lines.push("");
    }
  }

  fs.writeFileSync(webEnvPath, lines.join("\n"), "utf-8");
}

const DOCKER_PORT_VAR_MAP: Record<number, string> = {
  8000: "API_HOST_PORT",
  5432: "POSTGRES_HOST_PORT",
  6379: "REDIS_HOST_PORT",
  27017: "MONGO_HOST_PORT",
  5672: "RABBITMQ_HOST_PORT",
  8080: "CHROMADB_HOST_PORT",
  8083: "MONGO_EXPRESS_HOST_PORT",
  3000: "WEB_HOST_PORT",
};

export function writeDockerComposeEnv(
  repoRoot: string,
  portOverrides: Record<number, number>,
): void {
  const envPath = path.join(repoRoot, "infra", "docker", ".env");
  backupIfExists(envPath);

  const lines: string[] = [
    "# Docker Compose port overrides",
    "# Generated by GAIA CLI to resolve port conflicts",
    `# Created: ${new Date().toISOString()}`,
    "",
  ];

  for (const [original, replacement] of Object.entries(portOverrides)) {
    const origPort = Number(original);
    const varName = DOCKER_PORT_VAR_MAP[origPort];
    if (varName) {
      lines.push(`${varName}=${replacement}`);
    }
  }

  lines.push("");
  fs.writeFileSync(envPath, lines.join("\n"), "utf-8");
}

const DOCKER_PORT_VAR_TO_PORT: Record<string, number> = {
  API_HOST_PORT: 8000,
  POSTGRES_HOST_PORT: 5432,
  REDIS_HOST_PORT: 6379,
  MONGO_HOST_PORT: 27017,
  RABBITMQ_HOST_PORT: 5672,
  CHROMADB_HOST_PORT: 8080,
  MONGO_EXPRESS_HOST_PORT: 8083,
  WEB_HOST_PORT: 3000,
};

export function readDockerComposePortOverrides(
  repoRoot: string,
): Record<number, number> {
  const envPath = path.join(repoRoot, "infra", "docker", ".env");
  const overrides: Record<number, number> = {};

  if (!fs.existsSync(envPath)) {
    return overrides;
  }

  const content = fs.readFileSync(envPath, "utf-8");
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const [key, ...valueParts] = trimmed.split("=");
      if (key && DOCKER_PORT_VAR_TO_PORT[key]) {
        const port = Number(valueParts.join("=").trim());
        if (!Number.isNaN(port) && port > 0) {
          overrides[DOCKER_PORT_VAR_TO_PORT[key]] = port;
        }
      }
    }
  }

  return overrides;
}

/**
 * Check if the API .env file exists. Pass the monorepo root as repoRoot.
 */
export function envFileExists(repoRoot: string): boolean {
  return fs.existsSync(getApiEnvPath(repoRoot));
}

/**
 * Read and parse the API .env file. Pass the monorepo root as repoRoot.
 */
export function readEnvFile(repoRoot: string): EnvValues {
  const envPath = getApiEnvPath(repoRoot);

  if (!fs.existsSync(envPath)) {
    return {};
  }

  const content = fs.readFileSync(envPath, "utf-8");
  const values: EnvValues = {};

  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#")) {
      const [key, ...valueParts] = trimmed.split("=");
      if (key) {
        let value = valueParts.join("=").trim();
        // Check if value is quoted
        const isQuoted =
          (value.startsWith('"') && value.endsWith('"')) ||
          (value.startsWith("'") && value.endsWith("'"));
        if (isQuoted) {
          // Strip matching quotes, don't touch content
          value = value.slice(1, -1);
        } else {
          // Remove inline comments only for unquoted values
          const commentIdx = value.indexOf(" #");
          if (commentIdx !== -1) {
            value = value.substring(0, commentIdx).trim();
          }
        }
        values[key.trim()] = value;
      }
    }
  }

  return values;
}
